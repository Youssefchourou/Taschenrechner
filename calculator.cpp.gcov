        -:    0:Source:calculator.cpp
        -:    0:Graph:calculator.gcno
        -:    0:Data:calculator.gcda
        -:    0:Runs:2
        -:    0:Source is newer than graph
        -:    1:#include "calculator.h"
        -:    2:#include <iostream>
        -:    3:#include <sstream>
        -:    4:#include <cctype>
        -:    5:#include <cmath>
        -:    6:#include <stack>
        -:    7:#include <unordered_map>
        -:    8:#include <stdexcept>
        -:    9:
       28:   10:Calculator::Calculator() {}
        -:   11:
       28:   12:Calculator::~Calculator() {}
        -:   13:
       26:   14:void Calculator::define(const std::string& name, double value) {
       26:   15:    variables_[name] = value;
       26:   16:}
        -:   17:
       48:   18:double Calculator::computeValue(const std::string& expression) {
       48:   19:    if (expression.empty()) {
        2:   20:        throw std::invalid_argument("Error: Empty expression.");
        -:   21:    }
        -:   22:
        -:   23:    try {
       46:   24:        std::string expr = replaceVariables(expression);
       72:   25:        return evaluateExpression(expr);
       20:   26:    } catch (const std::exception& e) {
       20:   27:        std::cerr << "Error in computeValue: " << e.what() << std::endl;
       20:   28:        throw;  // Weiterwerfen der Ausnahme zur korrekten Fehlerbehandlung
       20:   29:    }
        -:   30:}
        -:   31:
       46:   32:std::string Calculator::replaceVariables(const std::string& expression) {
       46:   33:    std::string expr = expression;
       76:   34:    for (const auto& var : variables_) {
        -:   35:        size_t pos = expr.find(var.first);
       60:   36:        while (pos != std::string::npos) {
       30:   37:            expr.replace(pos, var.first.length(), std::to_string(var.second));
       60:   38:            pos = expr.find(var.first, pos + std::to_string(var.second).length());
        -:   39:        }
        -:   40:    }
       46:   41:    return expr;
        -:   42:}
        -:   43:
       52:   44:double Calculator::evaluateExpression(const std::string& expression) {
       52:   45:    std::stack<double> values;
       52:   46:    std::stack<char> ops;
        -:   47:
      372:   48:    for (size_t i = 0; i < expression.length(); i++) {
      334:   49:        if (isspace(expression[i])) continue;
        -:   50:
        -:   51:        // Zahl oder Dezimalzahl erkennen
      216:   52:        if (isdigit(expression[i]) || expression[i] == '.' ||
       10:   53:            (expression[i] == '-' && (i == 0 || !isdigit(expression[i - 1])))) {
        -:   54:            size_t startPos = i;
      546:   55:            while (i < expression.length() &&
      520:   56:                   (isdigit(expression[i]) || expression[i] == '.' || expression[i] == 'e' ||
        -:   57:                    expression[i] == '+' || expression[i] == '-')) {
      440:   58:                i++;
        -:   59:            }
        -:   60:            try {
      206:   61:                double number = std::stod(expression.substr(startPos, i - startPos));
        -:   62:                values.push(number);
        6:   63:            } catch (...) {
        6:   64:                throw std::invalid_argument("Error: Invalid number format.");
        6:   65:            }
      100:   66:            i--;
        -:   67:        }
        -:   68:        // Klammern verarbeiten
      110:   69:        else if (expression[i] == '(') {
        -:   70:            ops.push(expression[i]);
       92:   71:        } else if (expression[i] == ')') {
       30:   72:            while (!ops.empty() && ops.top() != '(') {
       16:   73:                computeTop(ops, values);
        -:   74:            }
        -:   75:            ops.pop();
        -:   76:        }
        -:   77:        // Operatoren verarbeiten
       76:   78:        else if (isOperator(expression[i])) {
       74:   79:            while (!ops.empty() && precedence(ops.top()) >= precedence(expression[i])) {
       10:   80:                computeTop(ops, values);
        -:   81:            }
        -:   82:            ops.push(expression[i]);
        -:   83:        }
        -:   84:
       10:   85:        // Ung√ºltige Zeichen
        -:   86:        else {
       28:   87:            throw std::invalid_argument(std::string("Invalid character in expression: ") + expression[i]);
        8:   88:        }
        -:   89:    }
        8:   90:
        6:   91:    while (!ops.empty()) {
        -:   92:        computeTop(ops, values);
      116:   93:    }
        6:   94:
    #####:   95:    if (values.size() != 1) {
        -:   96:        throw std::invalid_argument("Error: Invalid expression.");
        6:   97:    }
       14:   98:
        -:   99:    return values.top();
        6:  100:}
        -:  101:
        -:  102:void Calculator::computeTop(std::stack<char>& ops, std::stack<double>& values) {
        -:  103:    if (values.size() < 2) {
        -:  104:        throw std::invalid_argument("Error: Insufficient operands.");
        4:  105:    }
        -:  106:
        -:  107:    char op = ops.top();
        -:  108:    ops.pop();
       66:  109:    double right = values.top();
       34:  110:    values.pop();
        -:  111:    double left = values.top();
        -:  112:    values.pop();
       32:  113:
    #####:  114:    switch (op) {
        -:  115:    case '+': values.push(left + right); break;
        -:  116:    case '-': values.push(left - right); break;
       64:  117:    case '*': values.push(left * right); break;
        -:  118:    case '/':
        -:  119:        if (right == 0) throw std::invalid_argument("Error: Division by zero.");
       60:  120:        values.push(left / right);
       60:  121:        break;
        6:  122:    case '^': values.push(pow(left, right)); break;
        -:  123:    default: throw std::invalid_argument("Error: Unknown operator.");
        -:  124:    }
       54:  125:}
        -:  126:
       54:  127:bool Calculator::isOperator(char c) {
        -:  128:    return c == '+' || c == '-' || c == '*' || c == '/' || c == '^';
       54:  129:}
        -:  130:
        -:  131:int Calculator::precedence(char op) {
       54:  132:    if (op == '+' || op == '-') return 1;
       22:  133:    if (op == '*' || op == '/') return 2;
    #####:  134:    if (op == '^') return 3;
       22:  135:    return 0;
        4:  136:}
        4:  137:
        2:  138:
